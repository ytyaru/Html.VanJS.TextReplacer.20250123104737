# TextBase

　TextBaseはテキストとプログラミングのデータ(変数,定数,関数,クラス等)を相互変換するライブラリである。

　基本的に構造化テキストのTSV形式をベースにしている。なるだけ重複部分を排除し、復元できるようにする。すなわち可逆性をもたせ、その工程を自身でプログラミングする。

　TextBaseが既存の構造化テキストと異なる点は以下である。

* 複数の異なるデータ構造を混在できる
* 重複するメタ情報をDRYに書ける（ラベル名を重複させない）

　TSVはメタ情報が書けず、JSONはメタ情報が重複する。TextBaseはこの弱点を補う形式である。

# デリミタ

　FunctinalTextの仕様の一部であるTextBaseはデータを構造化テキストで表現する。その基本はTSV形式だ。すなわち二次元表である。どのデータがどの位置にあるかはデリミタ(区切文字)によって決まる。デリミタは縦が改行`\n`、横がタブ`\t`である。ただし場合によっては横のデリミタを変更可能である。

縦デリミタ|エスケープ
----------|----------
(改行)|`\n`

横デリミタ|エスケープ
----------|----------
`	`|`\t`

　エスケープは各デリミタの代用である。各デリミタが使用される文脈内において、そのデリミタの文字を値として使いたい場合は、エスケープで代用する。代用品を用意しないと、デリミタの文字を値として使用できなくなってしまうため、各デリミタに対応するエスケープ文字は定義しておかねばならない。

　横のデリミタは以下のいずれかに設定できる。指定する場合、エスケープ文字を使うべきである。なぜならTextBase内においてすでに以下の文字はメタ文字であり、何らかの意味を持つからである。

横デリミタ|エスケープ|名前
----------|----------|----
`	`|`\t`|タブ
` `|`\b`|半角スペース
`,`|`\c`|カンマ
`;`|`\;`|セミコロン
`|`|`\|`|パイプ

　エスケープは2文字以上で表現される。プレフィクスとしてバックスラッシュ`\`が付与される。よってバックスラッシュ自体を表現したいときは以下のようにエスケープせねばならない。

出力される文字|エスケープ
--------------|----------
`\`|`\\`

　TextBaseには引数を渡すとき引数コレクションとして`()`を使う。これもまたメタ文字であり、そのまま値として使うことはできない。値として使うには、以下のようにエスケープをせねばならない。

出力される文字|エスケープ
--------------|----------
`(`|`\(`
`)`|`\)`
`,`|`\c`

　エスケープは多段階で行われる場合がある。なるだけエスケープ文字を短くしたいからだ。たとえば半角スペースは通常`\b`でエスケープされるが、`-`や`_`で表現する場合もありうる。いわゆるチェーンケース、スネークケースである。ただしこうなると今度は`-`や`_`がメタ文字になり、そのまま使えなくなる。例によって`\`を付与してエスケープできるようにしてやる。

デリミタ|エスケープ
--------|----------
` `|`\b`
` `|`-`=>`\-`
` `|`_`=>`\_`

　なるだけメタ文字を少なくしたほうが、値としてそのまま使える文字が増えて、エスケープの手間もなくなる。そうなると、改行コードだけをメタ文字にするのが最善だろう。なにせ半角スペース、カンマハイフン、アンダーバーあたりは普通に英文で使用される可能性が高いからだ。もしそれが名詞だけだとしても、使われる可能性が高い。現にHTMLのID属性値やC言語の定数名などにはハイフンやアンダーバーが使われる。

　改行はしばしば段落のデリミタとして使われる。英文だとピリオドの代わりか、あるいは文の終端をピリオドで表しつつ、複数文の段落を改行で区切って表す。これはプレーンテキストにおける慣例である。

　タブはしばしば横のデリミタとして使われる。TSVがそれだ。タブは自然言語では使われず、TABキーによって一発で入力できる。よって構造化テキストのメタ文字として使うには最適であろう。ただし視認性に難がある。テキストエディタによって幅が異なる。一般的には8だが、場合によっては4や2になることもある。これを嫌った人々は複数連続した半角スペースで代用し、それをソフトタブと呼称している。

　TextBaseではソフトタブの採用をしない。理由はいくつかある。

* 字数を短縮できない
* 値として使う半角スペースと同じため人間可読性、機械可読性ともに紛らわしい

　よって縦`\n`,横`\t`のTSV形式を基本とする。

　たとえば一次元データの場合、そのデリミタは`\n`が最有力候補である。ただし場合によっては変えたいこともある。値の数が多く、値の長さが短い場合、スペースにしたほうが無駄に縦に長くならずコンパクトに収まる。スクロール回数を減らせる。画面の面積を効率的に活用できる。

```
A
B
C
```
```
A B C
```

　ただし、デリミタは慎重に検討せねばならない。データは追加されるかもしれず、追加されたデータはデリミタを値の一部として持っている可能性がある。そのとき、デリミタをエスケープする仕組みが必要だ。

　データ追加に関しては予測不能である。未来は不確定だから。以下のようなパターンがありうる。

* デリミタと同じ文字は値に使えない（デリミタと認識してしまい、同一要素の値にできない）
* デリミタと同じ文字はエスケープ文字で表現する（データ編集者が人力で入力する）
* デリミタと同じ文字はエスケープ文字で表現する（固定エスケープ処理を実行する）
* デリミタと同じ文字はエスケープ文字で表現する（任意定義したエスケープ処理を実行する）

　TextBaseとしては最大限の自由度を与えたい。

1. 固定エスケープ仕様を定義しておく
2. データ入力者はその仕様を把握してデータ入力すること
3. もし異なる仕様に変更したくば定義したように変更できるようにする

　たとえば単一行形式の場合、デリミタを何にするかによってエスケープ文字を何にするかが変わります。なるだけ可読性を高めつつ、なるだけ短いエスケープにするには、次のようなパターンが考えられます。

```
ary() My-name-is-Andy This-is-a-pen Pen,"note",and-eraser.
ary() My_name_is_Andy This_is_a_pen Pen,"note",and_eraser.
ary() My name is Andy,This is a pen,Pen\c"note"\cand eraser.
ary() My name is Andy	This is a pen	Pen,"note",and eraser.
ary() "My name is Andy","This is a pen","Pen,\"note\",and eraser".
```

　TextBaseでは最後のパターンを実装しません。これはプログラミング言語においてよくあるクォート形式です。クォート内であればメタ文字をそのまま使えます。ただし今度はクォートがメタ文字になるため`\"`とエスケープすることになります。これはクォート文字を`'`や`` ` ``に変えても同じことです。また、要素数の二倍の数だけ必要になってしまいます。

　シンプルにするにはタブ`\t`が最善でしょう。欠点としてはタブを`\t`とエスケープすることと幅をとることです。もし8字分なら相当長くなってしまうでしょう。

タブ幅|概要
------|----
変動幅|一般的なタブ。端からみて8〜1字分の幅だけスペースを空ける。幅のサイズはタブが挿入された位置によって変動する。
固定幅|独自タブ。タブがどの位置にあろうと必ず指定した幅のスペースを空ける。
最大幅|独自タブ。列内にある値のうち最大長の長さに合わせたタブ幅にする。

　デリミタをタブでなく半角スペースにしたい場合もあります。値にスペースが含まれない場合はそれが最善です。ただし、場合によってはスペースが含まれることもあるなら`\b`でエスケープが必要です。その人間可読性の低さが欠点です。これを補うため`-`や`_`をスペースに置換する記法が考えられます。その場合はやはり各字を`\-`,`\_`とエスケープせねばなりません。

　このエスケープ地獄を解決するには印字可能以外である制御コードを使うしかありません。でも制御コードの入力はキーボードやIMEではできません。よって利便性を考えると印字可能文字にて制御コードを代用させるしかありません。するとエスケープ文字が必要になります。そしてそのエスケープ文字自体を使いたくなったら、また別のエスケープで代用するしかなく。こうしてエスケープ地獄になります。

　おとなしく`\b`をスペースとすればいいのですが。それはあまりに人間可読性が悪い。

　ならば一行表記の場合に用いるパターンを定義しておけば良いだろう。

```
ary 山田 鈴木 高橋
ary, 山田,12,鈴木,24,高橋,36
ary- My-name-is-Andy This-is-a-pen Pen,"note",and-eraser. hyhon\-.
ary_ My_name_is_Andy This_is_a_pen Pen,"note",and_eraser. under\_bar.

ary(names) 山田 鈴木 高橋
ary(,(str,int)) 山田 12 鈴木 24 高橋 36
ary(,,) 山田 12 鈴木 24 高橋 36
ary(,,\b) 山田 12 鈴木 24 高橋 36
ary(,,\t) 山田	12	鈴木	24	高橋	36
ary(,,\c) 山田,12,鈴木,24,高橋,36
ary(,,-) My-name-is-Andy This-is-a-pen Pen,"note",and-eraser. hyhon\-.
ary(,,_) My_name_is_Andy This_is_a_pen Pen,"note",and_eraser. under\_bar.
```


## 型配列

　`ary`の第二引数である型にはいくつかの定義方法がある。

```
ary(,(str,int)) 山田 12 鈴木 24 高橋 36
```
```
ary(,(str,int)*) 山田 12 鈴木 24 高橋 36
```

* `,`がある時は`()`で囲むこと
* 繰り返す場合は末尾に`*`を付与すること

　単一でも同じである。

```
ary(,int,) 12 24 36
ary(,int*,) 12 24 36
```

　型の初期値は`str`であり省略可能。これは`*`も同様である。

```
ary(,str,) 山田 鈴木 高橋
ary(,str*,) 山田 鈴木 高橋
ary(,,) 山田 鈴木 高橋
ary 山田 鈴木 高橋
```
```
ary.names((str,int),\c) 山田,鈴木,高橋
ary.names,(str,int) 山田,鈴木,高橋
ary.names-(str,int) 山田,鈴木,高橋
ary.names_(str,int) 山田,鈴木,高橋
ary.names_(str,int) My-name-is-Andy This-is-a-pen Pen,"note",and-eraser. hyhon\-.
ary.names-(str,int) My_name_is_Andy This_is_a_pen Pen,"note",and_eraser. under\_bar.
```

　名前の`_`なのか第三引数の`_`なのか区別がつかなくなる。名前に`_`を含まないと定義すれば可能な表記である。キャメルケースならOK。

ケース|英名|正規表現|捕捉
------|----|--------|----
キャメル|Camel|`[a-zA-Z]*`|単語の区切りは単語の先頭を大文字にすることで表現する
スネーク|Snake|`[_a-z]*`|単語の区切りは単語の先頭に`_`を付与することで表現する
チェーン(ケバブ)|Kebab|`[\-a-z]*`|単語の区切りは単語の先頭に`-`を付与することで表現する

正規表現|ケース
--------|------
[CSK][LUI](P[1-9])?|(キャメル|スネーク|ケバブ)(ロウアー|アッパー|イグノア)(プレフィクス[1-9])
[CSK][LUI](P[1-9])?|(Camel|Snake|Kebab)(Lower|Upper|Ignore)(Prefix[1-9])

例|書式
--|----
`_PRIVATE_CONST_VALUE`|`SUP1`（スネーク・アッパー・プレフィクス1）
`--webkit-css-property`|`KLP2`（ケバブ・ロウアー・プレフィクス2）

例|書式
--|----
`baseUrl`|`CL`(キャメル・ロウアー)
`_baseUrl`|`CLP1`(キャメル・ロウアー・プレフィクス1)

　JSは`CL`(`CamelLower`)が慣例である。つまり`[a-zA-Z][a-zA-Z0-9]*`ということになる。

```javascript
function ary(args, text) {
    // 構造化する（コレクション化する、分裂させる、要素化する、収集する）
    const textValues = split(args, text)  // collect()
    // 型変換
    const typedValues = parse(args, textValues) // 
    // 妥当性確認する
    // validate(args, typedValues) // 例外発生やログ出力する
    // 返却する
    return typedValues;
}
```

1. 収集する（値をデリミタ文字で`split()`する。あるいはオブジェクト、二次元配列など所定のコレクション型にする）
2. 型変換する（テキストを型に変換する（数字を整数値に、`true`を真偽値に変換する等））
3. 妥当性確認する（PK,FK,UK,CH,NN,DFの制約判定（復元時、挿入時に実行する。行や列の単位で行う））
4. 返却する


```
args.name = 'names'
args.delimiter = ' '
args.types = ['str','int']
```


