# TextBase

　TextBaseはテキストとプログラミングのデータ(変数,定数,関数,クラス等)を相互変換するライブラリである。

　基本的に構造化テキストのTSV形式をベースにしている。なるだけ重複部分を排除し、復元できるようにする。すなわち可逆性をもたせ、その工程を自身でプログラミングする。

　TextBaseが既存の構造化テキストと異なる点は以下である。

* 複数の異なるデータ構造を混在できる
* 重複するメタ情報をDRYに書ける（ラベル名を重複させない）

　TSVはメタ情報が書けず、JSONはメタ情報が重複する。TextBaseはこの弱点を補う形式である。

# デリミタ

　FunctinalTextの仕様の一部であるTextBaseはデータを構造化テキストで表現する。その基本はTSV形式だ。すなわち二次元表である。どのデータがどの位置にあるかはデリミタ(区切文字)によって決まる。デリミタは縦が改行`\n`、横がタブ`\t`である。ただし場合によっては横のデリミタを変更可能である。

縦デリミタ|エスケープ
----------|----------
(改行)|`\n`

横デリミタ|エスケープ
----------|----------
`	`|`\t`

　エスケープは各デリミタの代用である。各デリミタが使用される文脈内において、そのデリミタの文字を値として使いたい場合は、エスケープで代用する。代用品を用意しないと、デリミタの文字を値として使用できなくなってしまうため、各デリミタに対応するエスケープ文字は定義しておかねばならない。

　横のデリミタは以下のいずれかに設定できる。指定する場合、エスケープ文字を使うべきである。なぜならTextBase内においてすでに以下の文字はメタ文字であり、何らかの意味を持つからである。

横デリミタ|エスケープ|名前
----------|----------|----
`	`|`\t`,`\   `|タブ
` `|`\b`,`\ `|半角スペース
`,`|`\c`,`\,`|カンマ
`;`|`\;`|セミコロン
`|`|`\|`|パイプ

　エスケープは2文字以上で表現される。プレフィクスとしてバックスラッシュ`\`が付与される。よってバックスラッシュ自体を表現したいときは以下のようにエスケープせねばならない。

出力される文字|エスケープ
--------------|----------
`\`|`\\`

　TextBaseには引数を渡すとき引数コレクションとして`()`を使う。これもまたメタ文字であり、そのまま値として使うことはできない。値として使うには、以下のようにエスケープをせねばならない。

出力される文字|エスケープ
--------------|----------
`(`|`\(`
`)`|`\)`
`,`|`\c`

　エスケープは多段階で行われる場合がある。なるだけエスケープ文字を短くしたいからだ。たとえば半角スペースは通常`\b`でエスケープされるが、`-`や`_`で表現する場合もありうる。いわゆるチェーンケース、スネークケースである。ただしこうなると今度は`-`や`_`がメタ文字になり、そのまま使えなくなる。例によって`\`を付与してエスケープできるようにしてやる。

デリミタ|エスケープ
--------|----------
` `|`\b`
` `|`-`=>`\-`
` `|`_`=>`\_`

　なるだけメタ文字を少なくしたほうが、値としてそのまま使える文字が増えて、エスケープの手間もなくなる。そうなると、改行コードだけをメタ文字にするのが最善だろう。なにせ半角スペース、カンマハイフン、アンダーバーあたりは普通に英文で使用される可能性が高いからだ。もしそれが名詞だけだとしても、使われる可能性が高い。現にHTMLのID属性値やC言語の定数名などにはハイフンやアンダーバーが使われる。

　改行はしばしば段落のデリミタとして使われる。英文だとピリオドの代わりか、あるいは文の終端をピリオドで表しつつ、複数文の段落を改行で区切って表す。これはプレーンテキストにおける慣例である。

　タブはしばしば横のデリミタとして使われる。TSVがそれだ。タブは自然言語では使われず、TABキーによって一発で入力できる。よって構造化テキストのメタ文字として使うには最適であろう。ただし視認性に難がある。テキストエディタによって幅が異なる。一般的には8だが、場合によっては4や2になることもある。これを嫌った人々は複数連続した半角スペースで代用し、それをソフトタブと呼称している。

　TextBaseではソフトタブの採用をしない。理由はいくつかある。

* 字数を短縮できない
* 値として使う半角スペースと同じため人間可読性、機械可読性ともに紛らわしい

　よって縦`\n`,横`\t`のTSV形式を基本とする。

　たとえば一次元データの場合、そのデリミタは`\n`が最有力候補である。ただし場合によっては変えたいこともある。値の数が多く、値の長さが短い場合、スペースにしたほうが無駄に縦に長くならずコンパクトに収まる。スクロール回数を減らせる。画面の面積を効率的に活用できる。

```
A
B
C
```
```
A B C
```

　ただし、デリミタは慎重に検討せねばならない。データは追加されるかもしれず、追加されたデータはデリミタを値の一部として持っている可能性がある。そのとき、デリミタをエスケープする仕組みが必要だ。

　データ追加に関しては予測不能である。未来は不確定だから。以下のようなパターンがありうる。

* デリミタと同じ文字は値に使えない（デリミタと認識してしまい、同一要素の値にできない）
* デリミタと同じ文字はエスケープ文字で表現する（データ編集者が人力で入力する）
* デリミタと同じ文字はエスケープ文字で表現する（固定エスケープ処理を実行する）
* デリミタと同じ文字はエスケープ文字で表現する（任意定義したエスケープ処理を実行する）

　TextBaseとしては最大限の自由度を与えたい。

1. 固定エスケープ仕様を定義しておく
2. データ入力者はその仕様を把握してデータ入力すること
3. もし異なる仕様に変更したくば定義したように変更できるようにする

　たとえば単一行形式の場合、デリミタを何にするかによってエスケープ文字を何にするかが変わります。なるだけ可読性を高めつつ、なるだけ短いエスケープにするには、次のようなパターンが考えられます。

```
ary() My-name-is-Andy This-is-a-pen Pen,"note",and-eraser.
ary() My_name_is_Andy This_is_a_pen Pen,"note",and_eraser.
ary() My name is Andy,This is a pen,Pen\c"note"\cand eraser.
ary() My name is Andy	This is a pen	Pen,"note",and eraser.
ary() "My name is Andy","This is a pen","Pen,\"note\",and eraser".
```

　TextBaseでは最後のパターンを実装しません。これはプログラミング言語においてよくあるクォート形式です。クォート内であればメタ文字をそのまま使えます。ただし今度はクォートがメタ文字になるため`\"`とエスケープすることになります。これはクォート文字を`'`や`` ` ``に変えても同じことです。また、要素数の二倍の数だけ必要になってしまいます。

　シンプルにするにはタブ`\t`が最善でしょう。欠点としてはタブを`\t`とエスケープすることと幅をとることです。もし8字分なら相当長くなってしまうでしょう。

タブ幅|概要
------|----
変動幅|一般的なタブ。端からみて8〜1字分の幅だけスペースを空ける。幅のサイズはタブが挿入された位置によって変動する。
固定幅|独自タブ。タブがどの位置にあろうと必ず指定した幅のスペースを空ける。
最大幅|独自タブ。列内にある値のうち最大長の長さに合わせたタブ幅にする。

　デリミタをタブでなく半角スペースにしたい場合もあります。値にスペースが含まれない場合はそれが最善です。ただし、場合によってはスペースが含まれることもあるなら`\b`でエスケープが必要です。その人間可読性の低さが欠点です。これを補うため`-`や`_`をスペースに置換する記法が考えられます。その場合はやはり各字を`\-`,`\_`とエスケープせねばなりません。

　このエスケープ地獄を解決するには印字可能以外である制御コードを使うしかありません。でも制御コードの入力はキーボードやIMEではできません。よって利便性を考えると印字可能文字にて制御コードを代用させるしかありません。するとエスケープ文字が必要になります。そしてそのエスケープ文字自体を使いたくなったら、また別のエスケープで代用するしかなく。こうしてエスケープ地獄になります。

　おとなしく`\b`をスペースとすればいいのですが。それはあまりに人間可読性が悪い。

　ならば一行表記の場合に用いるパターンを定義しておけば良いだろう。

```
ary 山田 鈴木 高橋
ary, 山田,12,鈴木,24,高橋,36
ary- My-name-is-Andy This-is-a-pen Pen,"note",and-eraser. hyhon\-.
ary_ My_name_is_Andy This_is_a_pen Pen,"note",and_eraser. under\_bar.

ary(names) 山田 鈴木 高橋
ary(,(str,int)) 山田 12 鈴木 24 高橋 36
ary(,,) 山田 12 鈴木 24 高橋 36
ary(,,\b) 山田 12 鈴木 24 高橋 36
ary(,,\t) 山田	12	鈴木	24	高橋	36
ary(,,\c) 山田,12,鈴木,24,高橋,36
ary(,,-) My-name-is-Andy This-is-a-pen Pen,"note",and-eraser. hyhon\-.
ary(,,_) My_name_is_Andy This_is_a_pen Pen,"note",and_eraser. under\_bar.
```

　型リストは`cols`として宣言したほうがいいかもしれない。

```
cols.human(name:str='',age:int=0)
ary(members,cols.human) 山田 12 鈴木 24 高橋 36
```

　値の型には`cols`を指定できる。すなわちネスト。でもネストしたらメタ文字をどうするか問題がある。

```
cols.skill(id:int=0,name:str='',power:int=0)
cols.human(name:str='',age:int=0,skill:[cols.skill.id])
ary(members,cols.human) 山田 12 0,1 鈴木 24 1,2 高橋 36 3,4,5
```

```
cols.A(id:int=0,name:str='')
cols.B(id:int=0,name:str='',values:[cols.A.id])
cols.C(id:int=0,name:str='',values:[cols.B.id])
cols.human(name:str='',age:int=0,skills:[cols.C.id])
rows(avs,cols.A) 0 A-Name-0 1 A-Name-1 2 A-Name-2 ...
rows(bvs,cols.B) 0 B-Name-0 0,1 1 B-Name-1 1,2 2 B-Name-2 2,3 ...
rows(cvs,cols.C) 0 C-Name-0 0,1 1 C-Name-1 1,2 2 C-Name-2 2,3 ...
rows(members,(str,int,ints)) 山田 12 0,1 鈴木 24 1,2 高橋 36 3,4,5
rows(members,(str,int,[int])) 山田 12 0,1 鈴木 24 1,2 高橋 36 3,4,5
ary(members,cols.human) 山田 12 0,1 鈴木 24 1,2 高橋 36 3,4,5
```
```
db.store.ary.members = [
  {name:'山田', age:12, values:[
    {id:0, name:'C-Name-0', values:[
      {id:0, name:'B-Name-0', values:[
        {id:0, name:'A-Name-0'}
      ]}
    ]}
  ]}
]
```
```
table.A(id:int=0,name:str='') 0 A-Name-0 1 A-Name-1 2 A-Name-2 ...
table.B(id:int=0,name:str='') 0 B-Name-0 0,1 1 B-Name-1 1,2 2 B-Name-2 2,3 ...
table.C(id:int=0,name:str='') 0 C-Name-0 0,1 1 C-Name-1 1,2 2 C-Name-2 2,3 ...
table.human(name:str='',age:int=0,skills:[cols.C.id]) 山田 12 0,1 鈴木 24 1,2 高橋 36 3,4,5
```

　表は複数行あるはずだが、それを一行で表現することも可能にしたい。列や行の数が少ない表を手軽に書きたいから。すると列と行のデリミタを` `にしたくなる。行列の区別は`cols`の要素数で決定する。

　`cols`の列名だけで型や制約の設定を継承できるようにしたい。たとえば`id`なら整数型であり主キーであることが毎回決まっているため、名前だけで型や制約を確定させたい。

```
typedName.name(string,'',CH:0<this.length)
typedName.id(integer,0,PK)
typedName.age(integer,0,CH:0<=this && this<=100)
```
```
typedName.name(string,\0,(v)=>0<v.length)
typedName.id(integer,0,PK)
typedName.age(integer,0,(v)=>0<=v && v<=100)
```

　キーには`PK`,`UK`,`FK`がある。キーは行検索や表結合で使う。

キー|概要
----|----
`PK`|主キー。一意の値を持つ列であり`NN`(NotNull)制約である。
`UK`|一意キー。一意の値を持つ列でありNULLを許容する。
`FK`|外部キー。別表の主キーを値に持つ列である。

　TextBaseにおいて全ての値はNN(`NotNull`)制約である。むしろ`null`を許容することはできないようにする。`int?`のように型名の末尾に`?`を付与すれば`null`許容型にできるようにする考えもあるが、問題は`null`のときは型が違うため、存在しないメソッドを呼び出そうとすると実行時エラーが発生してしまう所。そのせいでNULL判定する`if`文が大量発生してウザいため、基本的に`null`禁止とする。これを`null`安全と呼ぶ。

　尚、`??`,`?.`等、`null`を上手く扱う方法もあるが、それだけでは解決できず`null`判定が必要な状況もあるため、`null`を使わないこととする。たとえば`typeof`演算子だと、値が`null`のとき`object`を返してしまう。`String`や`Integer`、`Null`ですらなく、なぜか`object`を返す。明らかに意図に反する結果のため、`null`は使うべきでない。また、`undefined`も紛らわしいため、使うべきでない。

　そもそも`null`や`undefined`の値の意味は不透明である。未入力（まだ作業してない）なのか未回答（値が不明のため入力できない）なのか空値（どの値にも属さない何らかの状態）なのか不明である。`null`はあくまで参照先がないことを示す値にすぎない。これはポインタ変数の初期値でありデータの値として使うのは不適切である。`undefined`も同じくJS文脈における未定義を意味するものだから、データの値として使うのは間違った用法である。よって`null`や`undefined`はデータの値を定義するTextBase文脈内においては使用すべきでない値である。

　`NaN`や`Infinity`も同様だ。`NaN`は計算不能を意味しており値ではなくエラーである。`Infinity`は無限数であり、有限数との計算ができない。普通は有限数による計算をするものであり、ましてやデータであるTextBaseで使う値ではない。よって`NaN`や`Infinity`は使用すべきではない値である。

　未入力値は自動的に規定デフォルト値になる。あるいは指定デフォルト値にする。

型|規定デフォルト値
--|----------------
`ary`|`[]`
`obj`|`{}`
`set`|`new Set()`
`map`|`new Map()`

型|規定デフォルト値
--|----------------
`arys`|`[[],[],...]`
`objs`|`[{},{},...]`
`sets`|`[new Set(), ...]`
`mapt`|`[new Map(), ...]`

型|規定デフォルト値
--|----------------
`cols`|`[{name:'', type:'', defaultValue:'', validate:()=>{}}]`, `[name:type=defVal, ...]`
`rows`|`[[r1c1,r1c2],[r2c1,r2c1],...]`
`table`|`{cols:[],rows:[]}`
`enum`|`{key:{name:'', value:''}}`, `[{key:'', name:'', value:0},...]`
`flags`|`[{name:'isA', value:0},...]`, `{isA:true, isB:false, isC:true}`, `0b101`

型|規定デフォルト値
--|----------------
`setary`,`uniqary`,`uary`,`ids`|`[...new Set()]`
`objmap`|`{k:new Map(), ...}`

型|規定デフォルト値
--|----------------
`range`,`rng`|`[[1-800],[801-4000],[4001,20000],[20001,100000]]`
`range`,`rng`|`[{name:'掌編',range:[1-800]},{name:'SS',range:[801-4000]},{name:'短編',range:[4001-20000]},{name:'中編',range:[20001-100000]},{name:'長編', range:[100001-500000]},{name:'巨編',range:[500001-Infinity]}}]`

型|規定デフォルト値
--|----------------
`str`|``(空文字列。エスケープ文字`\0`または未入力)
`int`|`0`(-1,MIN,MAX等も候補になる。NaN,Infinityは計算時に例外発生するため使用禁止)
`flt`|`0.0`
`bln`|`false`

　真偽値をどう表記するか。

`false`|`true`|解説
-------|------|----
`0`|`1`|C言語などでは数値`0`を`false`,それ以外を`true`と判断する。
`F`|`T`|`False`と`True`の頭文字である。
`f`|`t`|`false`と`true`の頭文字である。
`x`|`o`|`❌`と`⭕`である。これは日本語圏における記号であり国際的には意味が逆になったり別の記号で表現する場合がある。
`O`|`X`|`❌`と`⭕`を大文字で表現した。
`_`|`v`|`❌`と`⭕`の英語圏版である。選挙の投票ではしばしばチェックをつけて真を表す記号に`✔`が使われる。英語圏における未回答は空欄だが、TextBaseでは意図した偽であることを明示するために`-`や`_`を用いることを提案する。`_`のほうが変数名として使いやすいか。

　真偽値型においてデフォルト値をセットした場合、未入力の空欄なら、デフォルト値になるようにすれば、かなり字数を省略できるだろう。

```
cols.members(name:str='',isMale:b01=0)
rows.members() 山田花子  鈴木一郎 1
```

　`cols.human.isMale`は男性なら真、女性なら偽で表現する。このときデフォルト値は`0`であり偽であり女性である。

　`rows.human`において第二引数の`isMale`のデフォルト値は`0`である。もし値が省略され、何も入力されていなければ`0`であり女性だ。最初の行である`山田花子`は女性なので、第二引数`isMale`は空欄にすることで`0`(女性)であることを示している。

　基本的に女性である場合、デフォルト値は女性にしておく。例外的に男性をメンバーとして受け入れる場合もあるが、そのときは`1`と明記する。これにより平時の入力が省力化され、なおかつ例外的なデータが目立つようになる。

　`enum`型も定義したい。すなわち`enum`で定義された値のいずれかのみ許容する型である。
```
enum.任意型名(表記字:名前=初期値,...)
```
```
enum.sex(M:male=0,F:female=1)
```
```
enum.sex(M:male=0,F:female=1)
cols.members(name:str,enum.sex=F) 山田花子  鈴木一郎 M
```

　値を省略すると`0`から始まる整数値を与えられます。

```
enum.sex(M:male,F:female)
```

　値はキーや名前と同じものを指定できます。

```
enum.sex(M:male={key},F:female={key})
enum.sex(M:male={name},F:female={name})
```

　キーは名前を変換したものが使えます。

```
enum.sex({name.toUpperCase()}:male,{name.toUpperCase()[0]}:female)
```

　もし全列において同じ場合。その処理を定式化して共用したい。

```
[male,female]=>((name,i)=>`${name}.toUpperCase()[0]}:${name}`)
enum.sex({name.toUpperCase()}:)

enum.sex.key(name)=>`${name.toUpperCase()[0]}`

enum.sex([male,female].(name)=>`${name.toUpperCase()[0]}`)
enum.sex(keys=enum.sex.key, male, female)
enum.sex(:male, :female, keys=(name)=>`${name.toUpperCase()[0]}`, )

enum.sex(keys=(name)=>`${name.toUpperCase()[0]}) :male :female

enum.sex() M:male=0 F:female=1

enum.sex(keys=((name,value)=>{}), names=(key,value)=>{}, values=(key,name)=>{}) M:male=0 F:female=1
```

　`enum`は真偽値の他にも使える。一つ以上の定義をもつ。

```javascript
enum.sex = {
  'M':{name:'male', value:0},
  'F':{name:'female', value:1},
}
```

　あるいはフラグのように併用したときその組合せが一意のバイナリになるような型が欲しい。以下は`isA`〜`isC`はそれぞれ真偽値を持っており、その値は`0b000`〜`0b111`の8通りで表せる。すなわち1バイト分のデータになる。このときテキスト表記をどうするか。二進数`0b000`のように表記するか十進数`0`にするか。編集性を考えると二進数表記がよい。圧縮性を考えると十進数表記がよい。統一的に十進数にするか？

```
flags.state(isA,isB,isC)
```
```
isA 0b001 1
isB 0b010 2
isC 0b100 4
```
```
flags.state(isA,isB,isC)
cols.some(name:str,state:flags.state)
rows.some(cols.some) 山田 0b000 鈴木 0b000
rows.some(cols.some) 山田 000 鈴木 000
rows.some(cols.some) 山田 0 鈴木 0
rows.some(cols.some) 山田 0b111 鈴木 0b111
rows.some(cols.some) 山田 111 鈴木 111
rows.some(cols.some) 山田 7 鈴木 7
```

　先述のように、質問に対する回答パターンには以下のようなものがありうる。

概念|仮名
----|----
未入力|`unset`（まだ作業していないのか、意図的に回答を避けたのか、意図的に回答を避けたことを悟られたくなくて回答拒否の意図すら明示しなかったのか、どうすればいいか判らなかったのか、考えるのが面倒なのか、興味がないのか一切不明。とにかく回答が得られなかった状態）
回答拒否|`refusal to answer`（回答を拒む意志を明示する。政治的判断か、単に面倒だったか、プライバシーの侵害と思ったか不明）
？値|`not clear`（回答を考えた結果、判らないことが判った。自身で答えが出せなかったことを明示する）
無値|`none value`（回答を考えた結果、何もなかった。自身の答えが無いことを明示する。言われたらじつは有ったと言うかもしれない）
選択値|`selected values`（用意された選択肢の中から選ぶ。それが全てであるとは言っていないし、そうだと判断するほど物を知らないかも）
自由値|`free value`（任意テキスト。その回答を見た者が理解できるとは限らない。伝わるとも限らない。個人の価値観で判断されてしまう）

　機械的に値の意味を定義しないと何を意図しているのか不明である。特に未入力の場合、その状態の意味は多岐に渡る。まだ質問を見ていないのか、質問は見たけど回答を考えている最中なのか、考えたけど何も思い浮かばないのか、思い浮かんだけどそれを回答しても良いか悩んでいるのか、政治的判断により心にもない意見を記述すべきと判断して忖度した答えなのか、忌憚なき意見を書いて自己主張した答えなのか。

　解答欄に記述された文章は、どのような意図によって書かれたのか。それが書かれていない。その意図によっては、全く異なる意味になるだろう。

　TextBaseで扱うデータは、あくまでバイナリ配列である。それを文字や数値などとして扱うことで、最終的に何らかのテキストに出力する意図がある。よって意図が不明瞭なデータは存在しない。それはあくまで`String`型のデータとして扱うのみである。また、基本的には一意なデータである。重複する部分は他のデータ識別として参照し、結合することで、最終結果を生成する。テキストを圧縮する意図がある。

　質問に対する回答など、データ構造として正規化できていないデータについては、TextBaseで扱うべきか疑問である。単なるTSVとして扱ったほうが適切かもしれない。扱えないわけではないが、重複回答がありうるためテキスト圧縮の意図にそぐわないし、自然言語による自由回答なら、同じ意図でも表記ゆれなどによって同一判定ができなくなるだろう。そのあたりの処理はテキストマイニングの領分でありTextBaseの領分外だ。

## 型配列

　`ary`の第二引数である型にはいくつかの定義方法がある。

```
ary(,(str,int)) 山田 12 鈴木 24 高橋 36
```
```
ary(,(str,int)*) 山田 12 鈴木 24 高橋 36
```

* `,`がある時は`()`で囲むこと
* 繰り返す場合は末尾に`*`を付与すること

　単一でも同じである。

```
ary(,int,) 12 24 36
ary(,int*,) 12 24 36
```

　型の初期値は`str`であり省略可能。これは`*`も同様である。

```
ary(,str,) 山田 鈴木 高橋
ary(,str*,) 山田 鈴木 高橋
ary(,,) 山田 鈴木 高橋
ary 山田 鈴木 高橋
```
```
ary.names((str,int),\c) 山田,鈴木,高橋
ary.names,(str,int) 山田,鈴木,高橋
ary.names-(str,int) 山田,鈴木,高橋
ary.names_(str,int) 山田,鈴木,高橋
ary.names_(str,int) My-name-is-Andy This-is-a-pen Pen,"note",and-eraser. hyhon\-.
ary.names-(str,int) My_name_is_Andy This_is_a_pen Pen,"note",and_eraser. under\_bar.
```

　名前の`_`なのか第三引数の`_`なのか区別がつかなくなる。名前に`_`を含まないと定義すれば可能な表記である。キャメルケースならOK。

ケース|英名|正規表現|捕捉
------|----|--------|----
キャメル|Camel|`[a-zA-Z]*`|単語の区切りは単語の先頭を大文字にすることで表現する
スネーク|Snake|`[_a-z]*`|単語の区切りは単語の先頭に`_`を付与することで表現する
チェーン(ケバブ)|Kebab|`[\-a-z]*`|単語の区切りは単語の先頭に`-`を付与することで表現する

正規表現|ケース
--------|------
[CSK][LUI](P[1-9])?|(キャメル|スネーク|ケバブ)(ロウアー|アッパー|イグノア)(プレフィクス[1-9])
[CSK][LUI](P[1-9])?|(Camel|Snake|Kebab)(Lower|Upper|Ignore)(Prefix[1-9])

例|書式
--|----
`_PRIVATE_CONST_VALUE`|`SUP1`（スネーク・アッパー・プレフィクス1）
`--webkit-css-property`|`KLP2`（ケバブ・ロウアー・プレフィクス2）

例|書式
--|----
`baseUrl`|`CL`(キャメル・ロウアー)
`_baseUrl`|`CLP1`(キャメル・ロウアー・プレフィクス1)

　JSは`CL`(`CamelLower`)が慣例である。つまり`[a-zA-Z][a-zA-Z0-9]*`ということになる。

```javascript
function ary(args, text) {
    // 構造化する（コレクション化する、分裂させる、要素化する、収集する）
    const textValues = split(args, text)  // collect()
    // 型変換
    const typedValues = parse(args, textValues) // 
    // 妥当性確認する
    // validate(args, typedValues) // 例外発生やログ出力する
    // 返却する
    return typedValues;
}
```

1. 収集する（値をデリミタ文字で`split()`する。あるいはオブジェクト、二次元配列など所定のコレクション型にする）
2. 型変換する（テキストを型に変換する（数字を整数値に、`true`を真偽値に変換する等））
3. 妥当性確認する（PK,FK,UK,CH,NN,DFの制約判定（復元時、挿入時に実行する。行や列の単位で行う））
4. 返却する


```
args.name = 'names'
args.delimiter = ' '
args.types = ['str','int']
```


